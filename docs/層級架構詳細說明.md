# Spring Boot 層級架構詳細說明
## Entity、Repository、DTO 與 DAO 模式比較

---

## 🏗️ **詳細層級說明**

### **1. Entity層 (實體類別)**

#### **定義**
- **Entity**: 資料庫表對應的Java物件
- **位置**: `src/main/java/com/library/entity/`
- **職責**: 定義資料庫表結構和關聯關係

#### **範例：User.java**
```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username", unique = true, nullable = false)
    private String username;
    
    @Column(name = "email", unique = true, nullable = false)
    private String email;
    
    @Column(name = "password", nullable = false)
    private String password;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "role_id")
    private Role role;
    
    // 建構函式、Getter/Setter、toString等
}
```

#### **Entity特點**
- ✅ **JPA註解**: 使用`@Entity`, `@Table`, `@Column`等
- ✅ **資料庫對應**: 直接對應資料庫表結構
- ✅ **關聯關係**: 定義表之間的關聯
- ✅ **驗證註解**: 可加入`@NotNull`, `@Size`等驗證

---

### **2. Repository層 (資料存取層)**

#### **定義**
- **Repository**: 資料庫操作的介面
- **位置**: `src/main/java/com/library/repository/`
- **職責**: 提供資料庫CRUD操作和自定義查詢

#### **範例：UserRepository.java**
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // 基本CRUD操作 (由JpaRepository提供)
    // save(), findById(), findAll(), delete() 等
    
    // 自定義查詢方法
    Optional<User> findByUsername(String username);
    
    Optional<User> findByEmail(String email);
    
    List<User> findByRole(Role role);
    
    @Query("SELECT u FROM User u WHERE u.isVerified = true")
    List<User> findAllVerifiedUsers();
    
    @Query("SELECT COUNT(u) FROM User u WHERE u.role = :role")
    long countByRole(@Param("role") Role role);
    
    // 複雜查詢
    @Query("SELECT u FROM User u " +
           "JOIN u.borrowRecords br " +
           "WHERE br.status = 'BORROWED' " +
           "AND br.dueAt < :date")
    List<User> findUsersWithOverdueBooks(@Param("date") LocalDateTime date);
}
```

#### **Repository特點**
- ✅ **介面定義**: 不需要實作，Spring Data JPA自動生成
- ✅ **方法命名**: 根據方法名自動生成SQL
- ✅ **自定義查詢**: 使用`@Query`註解
- ✅ **分頁排序**: 支援`Pageable`和`Sort`
- ✅ **事務管理**: 自動處理資料庫事務

---

### **3. DTO層 (資料傳輸物件)**

#### **定義**
- **DTO**: Data Transfer Object，用於API請求/回應的資料結構
- **位置**: `src/main/java/com/library/dto/`
- **職責**: 定義API的輸入輸出格式，與Entity分離

#### **範例：UserDto.java**
```java
// 請求DTO
public class UserRegistrationRequest {
    @NotBlank(message = "使用者名稱不能為空")
    @Size(min = 3, max = 50, message = "使用者名稱長度必須在3-50字元之間")
    private String username;
    
    @NotBlank(message = "電子郵件不能為空")
    @Email(message = "電子郵件格式不正確")
    private String email;
    
    @NotBlank(message = "密碼不能為空")
    @Size(min = 6, message = "密碼長度至少6字元")
    private String password;
    
    @NotBlank(message = "姓名不能為空")
    private String fullName;
    
    // Getter/Setter
}

// 回應DTO
public class UserResponse {
    private Long id;
    private String username;
    private String email;
    private String fullName;
    private String roleName;
    private boolean isVerified;
    private LocalDateTime createdAt;
    
    // 建構函式、Getter/Setter
}

// 登入請求DTO
public class LoginRequest {
    @NotBlank(message = "使用者名稱不能為空")
    private String username;
    
    @NotBlank(message = "密碼不能為空")
    private String password;
    
    // Getter/Setter
}
```

#### **DTO特點**
- ✅ **API導向**: 專門為API設計的資料結構
- ✅ **安全性**: 不暴露敏感資料（如密碼）
- ✅ **驗證**: 使用Bean Validation進行輸入驗證
- ✅ **版本控制**: 可獨立演進，不影響Entity
- ✅ **效能**: 只傳輸需要的資料

---

## 🔄 **資料流程**

### **完整資料流程範例**
```
HTTP請求 → Controller → DTO → Service → Repository → Entity → 資料庫
   ↓         ↓         ↓       ↓         ↓         ↓        ↓
API格式   請求處理   資料驗證  業務邏輯   資料存取   資料映射   資料儲存
```

#### **具體範例：使用者註冊**
```java
// 1. Controller接收請求
@PostMapping("/register")
public ResponseEntity<UserResponse> register(@Valid @RequestBody UserRegistrationRequest request) {
    UserResponse response = userService.register(request);
    return ResponseEntity.ok(response);
}

// 2. Service處理業務邏輯
@Service
public class UserService {
    public UserResponse register(UserRegistrationRequest request) {
        // 驗證業務規則
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new EmailAlreadyExistsException();
        }
        
        // 建立Entity
        User user = new User();
        user.setName(request.getName());
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        
        // 儲存到資料庫
        User savedUser = userRepository.save(user);
        
        // 轉換為回應DTO
        return UserResponse.from(savedUser);
    }
}
```

---

## 🤔 **為什麼不使用DAO模式？**

### **DAO vs Repository 比較**

#### **DAO模式 (舊式)**
```java
// DAO介面
public interface UserDAO {
    void save(User user);
    User findById(Long id);
    List<User> findAll();
    void update(User user);
    void delete(Long id);
}

// DAO實作
public class UserDAOImpl implements UserDAO {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Override
    public void save(User user) {
        String sql = "INSERT INTO users (name, email, password) VALUES (?, ?, ?)";
        jdbcTemplate.update(sql, user.getName(), user.getEmail(), user.getPassword());
    }
    
    @Override
    public User findById(Long id) {
        String sql = "SELECT * FROM users WHERE id = ?";
        return jdbcTemplate.queryForObject(sql, new UserRowMapper(), id);
    }
    
    // 需要手動實作所有方法...
}
```

#### **Repository模式 (現代)**
```java
// Repository介面
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // 自動提供所有基本CRUD操作
    // 只需要定義自定義查詢方法
    Optional<User> findByEmail(String email);
}
```

### **為什麼Repository更好？**

#### **1. 開發效率**
- ✅ **自動生成**: Spring Data JPA自動實作基本CRUD
- ✅ **方法命名**: 根據方法名自動生成SQL
- ✅ **減少樣板程式碼**: 不需要手動實作每個方法

#### **2. 型別安全**
- ✅ **編譯時檢查**: 方法名錯誤會在編譯時發現
- ✅ **IDE支援**: 更好的自動補全和重構支援

#### **3. 功能豐富**
- ✅ **分頁排序**: 內建支援
- ✅ **事務管理**: 自動處理
- ✅ **快取支援**: 容易整合快取

#### **4. 測試便利**
- ✅ **Mock支援**: 容易進行單元測試
- ✅ **測試資料庫**: 支援H2等記憶體資料庫

---

## 📊 **層級職責總結**

| 層級 | 職責 | 範例 | 特點 |
|------|------|------|------|
| **Entity** | 資料庫表對應 | `User.java` | JPA註解、資料庫對應 |
| **Repository** | 資料庫操作 | `UserRepository.java` | 自動生成、自定義查詢 |
| **DTO** | API資料格式 | `UserDto.java` | 驗證、安全性、版本控制 |
| **Service** | 業務邏輯 | `UserService.java` | 業務規則、事務管理 |
| **Controller** | HTTP處理 | `UserController.java` | 請求處理、回應格式化 |

---

## 🎯 **最佳實踐**

### **1. Entity設計**
- 使用JPA註解定義表結構
- 設定適當的關聯關係
- 加入必要的驗證註解

### **2. Repository設計**
- 繼承JpaRepository獲得基本CRUD
- 使用有意義的方法名
- 複雜查詢使用@Query註解

### **3. DTO設計**
- 為不同API設計不同的DTO
- 使用Bean Validation進行驗證
- 避免暴露敏感資料

### **4. 層級分離**
- 每層只負責自己的職責
- 避免跨層直接存取
- 使用依賴注入管理依賴

---

**這就是現代Spring Boot專案的標準架構！Repository模式比DAO更高效、更安全、更易維護。**
