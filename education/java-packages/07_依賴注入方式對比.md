# 依賴注入方式對比

## 📋 **學習目標**

本文件將詳細比較Spring中三種依賴注入方式的差異，幫助您理解為什麼推薦使用建構函式注入。

### **學習重點**
- 了解三種依賴注入方式的差異
- 理解為什麼推薦建構函式注入
- 掌握各種注入方式的適用場景
- 學會如何選擇合適的注入方式

---

## 🎯 **依賴注入概述**

### **什麼是依賴注入？**

依賴注入（Dependency Injection, DI）是Spring框架的核心概念，讓物件不需要自己建立依賴，而是由Spring容器提供。

```java
// ❌ 沒有依賴注入 - 物件自己建立依賴
public class UserService {
    private UserRepository userRepository;
    
    public UserService() {
        // 物件自己建立依賴 - 耦合度高
        this.userRepository = new UserRepository();
    }
}

// ✅ 有依賴注入 - 外部提供依賴
@Service
public class UserService {
    private final UserRepository userRepository;
    
    // 依賴由Spring容器提供
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

---

## 🔧 **三種依賴注入方式**

### **1. 建構函式注入（Constructor Injection）**

```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;
    
    // 建構函式注入
    public UserService(UserRepository userRepository, 
                      RoleRepository roleRepository, 
                      PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
    }
}
```

### **2. Setter注入（Setter Injection）**

```java
@Service
public class UserService {
    private UserRepository userRepository;
    private RoleRepository roleRepository;
    private PasswordEncoder passwordEncoder;
    
    // Setter注入
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Autowired
    public void setRoleRepository(RoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }
    
    @Autowired
    public void setPasswordEncoder(PasswordEncoder passwordEncoder) {
        this.passwordEncoder = passwordEncoder;
    }
}
```

### **3. 欄位注入（Field Injection）**

```java
@Service
public class UserService {
    // 欄位注入
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
}
```

---

## 📊 **詳細對比分析**

### **1. 依賴的強制性**

#### **建構函式注入 - 強制性**
```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    
    // 必須提供所有依賴，否則無法建立物件
    public UserService(UserRepository userRepository, RoleRepository roleRepository) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
    }
}

// 使用時
UserService userService = new UserService(userRepo, roleRepo);  // 必須提供所有參數
```

#### **Setter注入 - 可選性**
```java
@Service
public class UserService {
    private UserRepository userRepository;
    private RoleRepository roleRepository;
    
    // 依賴是可選的，可以不提供
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Autowired
    public void setRoleRepository(RoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }
}

// 使用時
UserService userService = new UserService();  // 可以不提供依賴
// 但可能導致 NullPointerException
```

#### **欄位注入 - 隱藏性**
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;  // 依賴關係隱藏
    
    @Autowired
    private RoleRepository roleRepository;  // 依賴關係隱藏
}

// 使用時
UserService userService = new UserService();  // 看起來沒有依賴
// 但實際上依賴 userRepository 和 roleRepository
```

### **2. 不可變性**

#### **建構函式注入 - 不可變**
```java
@Service
public class UserService {
    private final UserRepository userRepository;  // final 確保不可變
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    // 無法修改 userRepository
    // this.userRepository = newUserRepository;  // 編譯錯誤
}
```

#### **Setter注入 - 可變**
```java
@Service
public class UserService {
    private UserRepository userRepository;  // 可以修改
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    // 可以修改 userRepository
    public void changeRepository(UserRepository newUserRepository) {
        this.userRepository = newUserRepository;  // 可以修改
    }
}
```

#### **欄位注入 - 可變**
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;  // 可以修改
    
    // 可以修改 userRepository
    public void changeRepository(UserRepository newUserRepository) {
        this.userRepository = newUserRepository;  // 可以修改
    }
}
```

### **3. 測試便利性**

#### **建構函式注入 - 容易測試**
```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    
    public UserService(UserRepository userRepository, RoleRepository roleRepository) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
    }
    
    public User registerUser(String username, String email, String password) {
        // 業務邏輯
        return userRepository.save(new User(username, email, password));
    }
}

// 測試 - 不需要Spring容器
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private RoleRepository roleRepository;
    
    @Test
    void testRegisterUser() {
        // Given
        when(userRepository.save(any(User.class))).thenReturn(new User());
        
        // When - 直接建立物件，不需要Spring容器
        UserService userService = new UserService(userRepository, roleRepository);
        User result = userService.registerUser("test", "test@example.com", "password");
        
        // Then
        assertNotNull(result);
        verify(userRepository).save(any(User.class));
    }
}
```

#### **Setter注入 - 測試較複雜**
```java
@Service
public class UserService {
    private UserRepository userRepository;
    private RoleRepository roleRepository;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Autowired
    public void setRoleRepository(RoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }
}

// 測試 - 需要手動設定依賴
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private RoleRepository roleRepository;
    
    @Test
    void testRegisterUser() {
        // Given
        UserService userService = new UserService();
        userService.setUserRepository(userRepository);  // 手動設定依賴
        userService.setRoleRepository(roleRepository);  // 手動設定依賴
        
        when(userRepository.save(any(User.class))).thenReturn(new User());
        
        // When
        User result = userService.registerUser("test", "test@example.com", "password");
        
        // Then
        assertNotNull(result);
    }
}
```

#### **欄位注入 - 測試困難**
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RoleRepository roleRepository;
}

// 測試 - 需要Spring容器或反射
@SpringBootTest  // 需要整個Spring容器
class UserServiceTest {
    
    @Autowired
    private UserService userService;  // 依賴Spring容器
    
    @Test
    void testRegisterUser() {
        // 測試複雜，需要資料庫
        // 無法進行純單元測試
    }
}

// 或者使用反射（不推薦）
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Test
    void testRegisterUser() throws Exception {
        // Given
        UserService userService = new UserService();
        
        // 使用反射設定私有欄位（複雜且不推薦）
        Field userRepositoryField = UserService.class.getDeclaredField("userRepository");
        userRepositoryField.setAccessible(true);
        userRepositoryField.set(userService, userRepository);
        
        when(userRepository.save(any(User.class))).thenReturn(new User());
        
        // When
        User result = userService.registerUser("test", "test@example.com", "password");
        
        // Then
        assertNotNull(result);
    }
}
```

### **4. 循環依賴檢測**

#### **建構函式注入 - 編譯時檢測**
```java
// ❌ 循環依賴 - 編譯時就會發現
@Service
public class UserService {
    private final RoleService roleService;
    
    public UserService(RoleService roleService) {  // 編譯時發現循環依賴
        this.roleService = roleService;
    }
}

@Service
public class RoleService {
    private final UserService userService;
    
    public RoleService(UserService userService) {  // 編譯時發現循環依賴
        this.userService = userService;
    }
}

// 編譯錯誤：Circular dependency detected
```

#### **Setter注入 - 執行時檢測**
```java
// ❌ 循環依賴 - 執行時才發現
@Service
public class UserService {
    private RoleService roleService;
    
    @Autowired
    public void setRoleService(RoleService roleService) {  // 執行時才發現
        this.roleService = roleService;
    }
}

@Service
public class RoleService {
    private UserService userService;
    
    @Autowired
    public void setUserService(UserService userService) {  // 執行時才發現
        this.userService = userService;
    }
}

// 執行時錯誤：BeanCurrentlyInCreationException
```

#### **欄位注入 - 執行時檢測**
```java
// ❌ 循環依賴 - 執行時才發現
@Service
public class UserService {
    @Autowired
    private RoleService roleService;  // 執行時才發現
}

@Service
public class RoleService {
    @Autowired
    private UserService userService;  // 執行時才發現
}

// 執行時錯誤：BeanCurrentlyInCreationException
```

---

## ⚠️ **常見問題和陷阱**

### **問題1: 欄位注入的NullPointerException**

```java
// ❌ 欄位注入的問題
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;  // 可能為null
    
    public void createUser(String username) {
        // 如果Spring容器沒有找到UserRepository，這裡會拋出NullPointerException
        userRepository.save(new User(username));  // NullPointerException!
    }
}

// 測試時
@Test
void testCreateUser() {
    UserService userService = new UserService();
    userService.createUser("test");  // NullPointerException!
}
```

### **問題2: 建構函式注入的保護**

```java
// ✅ 建構函式注入的保護
@Service
public class UserService {
    private final UserRepository userRepository;  // 保證不為null
    
    public UserService(UserRepository userRepository) {
        // 建構時就確保有值
        this.userRepository = userRepository;
    }
    
    public void createUser(String username) {
        // userRepository 保證不為null
        userRepository.save(new User(username));
    }
}

// 測試時
@Test
void testCreateUser() {
    UserRepository mockRepo = mock(UserRepository.class);
    UserService userService = new UserService(mockRepo);  // 保證有依賴
    userService.createUser("test");  // 不會有NullPointerException
}
```

### **問題3: IDE支援差異**

#### **建構函式注入 - IDE支援良好**
```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    
    public UserService(UserRepository userRepository, RoleRepository roleRepository) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
    }
}

// IDE可以：
// 1. 自動重構時追蹤依賴關係
// 2. 提供自動完成建議
// 3. 檢測未使用的依賴
// 4. 提供重構建議
```

#### **欄位注入 - IDE支援有限**
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RoleRepository roleRepository;
}

// IDE限制：
// 1. 難以追蹤依賴關係
// 2. 重構時容易遺漏
// 3. 無法檢測未使用的依賴
// 4. 自動完成支援有限
```

---

## 🎯 **適用場景**

### **建構函式注入適用場景**
- ✅ **所有Service類別**
- ✅ **所有Repository類別**
- ✅ **所有Controller類別**
- ✅ **有強制依賴的類別**
- ✅ **需要測試的類別**

### **Setter注入適用場景**
- ⚠️ **可選依賴**
- ⚠️ **需要動態修改依賴的場景**
- ⚠️ **遺留系統的相容性**

### **欄位注入適用場景**
- ❌ **不推薦使用**
- ❌ **僅在特殊情況下使用**
- ❌ **遺留系統維護**

---

## 📚 **最佳實踐**

### **1. 優先使用建構函式注入**

```java
// ✅ 推薦做法
@Service
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;
    
    public UserService(UserRepository userRepository, 
                      RoleRepository roleRepository, 
                      PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
    }
}
```

### **2. 使用final關鍵字**

```java
// ✅ 使用final確保不可變
private final UserRepository userRepository;  // 不可修改
private final RoleRepository roleRepository;  // 不可修改
```

### **3. 避免過多依賴**

```java
// ❌ 依賴過多
@Service
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final EmailService emailService;
    private final NotificationService notificationService;
    private final AuditService auditService;
    private final CacheService cacheService;
    // ... 更多依賴
    
    public UserService(UserRepository userRepository, 
                      RoleRepository roleRepository,
                      EmailService emailService,
                      NotificationService notificationService,
                      AuditService auditService,
                      CacheService cacheService) {
        // 建構函式過長
    }
}

// ✅ 重構為多個Service
@Service
public class UserService {
    private final UserRepository userRepository;
    private final UserNotificationService userNotificationService;  // 組合多個服務
    
    public UserService(UserRepository userRepository, 
                      UserNotificationService userNotificationService) {
        this.userRepository = userRepository;
        this.userNotificationService = userNotificationService;
    }
}
```

### **4. 編寫完整的測試**

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private RoleRepository roleRepository;
    
    @Mock
    private PasswordEncoder passwordEncoder;
    
    private UserService userService;
    
    @BeforeEach
    void setUp() {
        userService = new UserService(userRepository, roleRepository, passwordEncoder);
    }
    
    @Test
    void testRegisterUser() {
        // Given
        when(roleRepository.findByName("USER")).thenReturn(Optional.of(new Role()));
        when(passwordEncoder.encode("password")).thenReturn("encodedPassword");
        when(userRepository.save(any(User.class))).thenReturn(new User());
        
        // When
        User result = userService.registerUser("test", "test@example.com", "password", "Test User");
        
        // Then
        assertNotNull(result);
        verify(userRepository).save(any(User.class));
    }
}
```

---

## 📊 **總結對比表**

| 特性 | 建構函式注入 | Setter注入 | 欄位注入 |
|------|-------------|-----------|----------|
| **依賴強制性** | ✅ 強制 | ⚠️ 可選 | ❌ 隱藏 |
| **不可變性** | ✅ 不可變 | ❌ 可變 | ❌ 可變 |
| **測試便利性** | ✅ 容易 | ⚠️ 中等 | ❌ 困難 |
| **循環依賴檢測** | ✅ 編譯時 | ❌ 執行時 | ❌ 執行時 |
| **IDE支援** | ✅ 良好 | ⚠️ 中等 | ❌ 有限 |
| **程式碼清晰度** | ✅ 清晰 | ⚠️ 中等 | ❌ 隱藏 |
| **重構安全性** | ✅ 安全 | ⚠️ 中等 | ❌ 危險 |
| **推薦程度** | ✅ 強烈推薦 | ⚠️ 謹慎使用 | ❌ 避免使用 |

---

## 🎓 **學習檢查清單**

- [ ] 了解三種依賴注入方式的差異
- [ ] 理解建構函式注入的優點
- [ ] 掌握欄位注入的問題
- [ ] 學會如何選擇合適的注入方式
- [ ] 能夠編寫建構函式注入的程式碼
- [ ] 能夠進行依賴注入的測試
- [ ] 了解循環依賴的問題
- [ ] 掌握最佳實踐

---

**記住：建構函式注入是Spring依賴注入的最佳實踐，應該優先使用！**
