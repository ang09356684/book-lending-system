# 階段7: 權限控制建立

## 📋 **階段目標**

在這個階段，我們將實作 Spring Security 和 JWT 認證機制，為我們的圖書借閱系統建立完整的權限控制。

### **學習重點：**
- Spring Security 的基本概念和配置
- JWT (JSON Web Token) 的生成和驗證
- 角色基礎的權限控制 (RBAC)
- 無狀態認證的實作

---

## 🎯 **Spring Security 核心概念**

### **什麼是 Spring Security？**

Spring Security 是 Spring 框架的安全模組，提供：
- **認證 (Authentication)**: 確認使用者身份
- **授權 (Authorization)**: 控制使用者可以存取哪些資源
- **會話管理**: 管理使用者登入狀態
- **密碼加密**: 安全地儲存密碼

### **Spring Security 架構：**

```
HTTP Request → Security Filter Chain → Authentication → Authorization → Response
```

1. **Filter Chain**: 過濾器鏈，處理所有請求
2. **Authentication**: 驗證使用者身份
3. **Authorization**: 檢查使用者權限
4. **UserDetailsService**: 載入使用者資訊

---

## 🔐 **JWT (JSON Web Token) 認證**

### **什麼是 JWT？**

JWT 是一種開放標準，用於在各方之間安全地傳輸資訊。它由三部分組成：
- **Header**: 演算法和 token 類型
- **Payload**: 包含聲明 (claims)
- **Signature**: 用於驗證 token 的簽名

### **JWT 的優點：**
- ✅ **無狀態**: 伺服器不需要儲存會話資訊
- ✅ **可擴展**: 適合分散式系統
- ✅ **自包含**: Token 包含所有必要資訊
- ✅ **跨域支援**: 可以在不同域名間使用

### **JWT 工作流程：**

```
1. 使用者登入 → 2. 驗證成功 → 3. 生成 JWT → 4. 返回 Token
5. 後續請求帶 Token → 6. 驗證 Token → 7. 授權存取
```

---

## 🏗️ **實作步驟**

### **步驟1: JWT Token Provider**

建立 `JwtTokenProvider` 類別，負責生成和驗證 JWT Token：

```java
@Component
public class JwtTokenProvider {
    
    @Value("${app.jwt.secret:defaultSecretKeyForDevelopmentOnly}")
    private String jwtSecret;
    
    @Value("${app.jwt.expiration:86400000}") // 24 hours
    private long jwtExpirationMs;
    
    // Generate JWT token from authentication
    public String generateToken(Authentication authentication) {
        UserDetails userPrincipal = (UserDetails) authentication.getPrincipal();
        return generateTokenFromUsername(userPrincipal.getUsername());
    }
    
    // Validate JWT token
    public boolean validateToken(String token) {
        try {
            SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes());
            Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}
```

### **步驟2: JWT 認證過濾器**

建立 `JwtAuthenticationFilter`，從 HTTP 請求中提取 JWT Token：

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);
            
            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromToken(jwt);
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("Could not set user authentication in security context", ex);
        }
        
        filterChain.doFilter(request, response);
    }
}
```

### **步驟3: 自定義 UserDetailsService**

建立 `CustomUserDetailsService`，從資料庫載入使用者資訊：

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
        
        return createUserDetails(user);
    }
    
    private UserDetails createUserDetails(User user) {
        String role = user.getRole() != null ? user.getRole().getName() : "USER";
        
        return org.springframework.security.core.userdetails.User.builder()
            .username(user.getUsername())
            .password(user.getPassword())
            .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + role)))
            .disabled(!user.getIsVerified())
            .build();
    }
}
```

### **步驟4: Spring Security 配置**

建立 `SecurityConfig`，配置認證和授權規則：

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                // Public endpoints - no authentication required
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/books/**").permitAll()
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                
                // Endpoints requiring authentication
                .requestMatchers("/api/borrows/**").authenticated()
                .requestMatchers("/api/users/**").authenticated()
                
                // Endpoints requiring specific roles
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/librarian/**").hasRole("LIBRARIAN")
                
                // All other requests require authentication
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
```

### **步驟5: 更新 AuthController**

在 `AuthController` 中添加登入功能：

```java
@PostMapping("/login")
public ResponseEntity<ApiResponse<LoginResponse>> login(@RequestBody @Valid LoginRequest request) {
    Authentication authentication = authenticationManager.authenticate(
        new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
    );
    
    SecurityContextHolder.getContext().setAuthentication(authentication);
    String jwt = tokenProvider.generateToken(authentication);
    
    User user = userService.findByUsername(request.getUsername());
    LoginResponse loginResponse = new LoginResponse(jwt, user);
    
    return ResponseEntity.ok(ApiResponse.success(loginResponse, "Login successful"));
}
```

### **步驟6: 密碼加密**

更新 `UserService` 以使用 BCrypt 密碼加密：

```java
@Service
public class UserService {
    
    private final PasswordEncoder passwordEncoder;
    
    public User registerUser(String username, String email, String password, String fullName) {
        // Encrypt password
        String encodedPassword = passwordEncoder.encode(password);
        
        // Create user with encrypted password
        User user = new User(username, encodedPassword, email, fullName, userRole);
        return userRepository.save(user);
    }
}
```

---

## 🔑 **權限控制機制**

### **角色基礎權限控制 (RBAC)**

我們實作了三種角色：

1. **USER**: 一般使用者
   - 可以借還書
   - 可以查看自己的借閱記錄
   - 可以搜尋書籍

2. **LIBRARIAN**: 圖書館員
   - 擁有 USER 的所有權限
   - 可以管理書籍
   - 可以處理借還書業務

3. **ADMIN**: 系統管理員
   - 擁有所有權限
   - 可以管理使用者
   - 可以查看系統統計

### **API 端點權限配置**

```java
// Public endpoints - no authentication required
.requestMatchers("/api/auth/**").permitAll()        // 註冊、登入
.requestMatchers("/api/books/**").permitAll()       // 書籍查詢
.requestMatchers("/swagger-ui/**").permitAll()      // API 文件

// Endpoints requiring authentication
.requestMatchers("/api/borrows/**").authenticated() // 借還書
.requestMatchers("/api/users/**").authenticated()   // 使用者管理

// Endpoints requiring specific roles
.requestMatchers("/api/admin/**").hasRole("ADMIN")           // 管理員功能
.requestMatchers("/api/librarian/**").hasRole("LIBRARIAN")   // 館員功能
```

---

## 🧪 **測試權限控制**

### **測試步驟：**

1. **註冊使用者**
   ```bash
   POST /api/auth/register
   {
     "username": "testuser",
     "email": "test@example.com",
     "password": "password123",
     "fullName": "Test User"
   }
   ```

2. **登入取得 Token**
   ```bash
   POST /api/auth/login
   {
     "username": "testuser",
     "password": "password123"
   }
   ```

3. **使用 Token 存取受保護的 API**
   ```bash
   GET /api/borrows/user/1
   Authorization: Bearer <your-jwt-token>
   ```

### **預期結果：**
- ✅ 沒有 Token 的請求會被拒絕 (401 Unauthorized)
- ✅ 無效 Token 的請求會被拒絕 (401 Unauthorized)
- ✅ 有效 Token 的請求會被允許
- ✅ 角色權限會正確限制存取

---

## ⚙️ **配置檔案**

### **application.yml 配置**

```yaml
app:
  jwt:
    secret: your-secret-key-here-make-it-long-and-secure
    expiration: 86400000  # 24 hours in milliseconds
```

### **重要安全注意事項：**

1. **JWT Secret**: 在生產環境中必須使用強密鑰
2. **Token 過期時間**: 設定合理的過期時間
3. **HTTPS**: 在生產環境中必須使用 HTTPS
4. **密碼策略**: 實作強密碼要求

---

## 📚 **相關概念解釋**

### **@EnableWebSecurity**
啟用 Spring Security 的 Web 安全功能。

### **@EnableMethodSecurity**
啟用方法級別的安全註解，如 `@PreAuthorize`。

### **SessionCreationPolicy.STATELESS**
設定為無狀態模式，不建立 HTTP 會話。

### **BCryptPasswordEncoder**
使用 BCrypt 演算法加密密碼，提供鹽值和多次雜湊。

### **SimpleGrantedAuthority**
Spring Security 的權限表示類別，格式為 "ROLE_角色名稱"。

---

## 🎯 **階段完成檢查清單**

- [x] JWT Token Provider 實作
- [x] JWT 認證過濾器實作
- [x] 自定義 UserDetailsService 實作
- [x] Spring Security 配置
- [x] 登入 API 實作
- [x] 密碼加密整合
- [x] 角色權限配置
- [x] API 端點權限設定

---

## 🚀 **下一步**

現在我們已經完成了權限控制系統的實作！接下來可以：

1. **階段8: API 文件 (Springdoc OpenAPI)**
   - 配置 Swagger UI
   - 為 API 添加文件註解
   - 測試 API 文件頁面

2. **階段9: 單元測試**
   - 為 Service 層編寫測試
   - 為 Controller 層編寫測試
   - 測試權限控制功能

---

**恭喜！您已經成功實作了完整的權限控制系統！** 🎉
