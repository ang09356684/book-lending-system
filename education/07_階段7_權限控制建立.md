# éšæ®µ7: æ¬Šé™æ§åˆ¶å»ºç«‹

## ğŸ“‹ **éšæ®µç›®æ¨™**

åœ¨é€™å€‹éšæ®µï¼Œæˆ‘å€‘å°‡å¯¦ä½œ Spring Security å’Œ JWT èªè­‰æ©Ÿåˆ¶ï¼Œç‚ºæˆ‘å€‘çš„åœ–æ›¸å€Ÿé–±ç³»çµ±å»ºç«‹å®Œæ•´çš„æ¬Šé™æ§åˆ¶ã€‚

### **å­¸ç¿’é‡é»ï¼š**
- Spring Security çš„åŸºæœ¬æ¦‚å¿µå’Œé…ç½®
- JWT (JSON Web Token) çš„ç”Ÿæˆå’Œé©—è­‰
- è§’è‰²åŸºç¤çš„æ¬Šé™æ§åˆ¶ (RBAC)
- ç„¡ç‹€æ…‹èªè­‰çš„å¯¦ä½œ

---

## ğŸ¯ **Spring Security æ ¸å¿ƒæ¦‚å¿µ**

### **ä»€éº¼æ˜¯ Spring Securityï¼Ÿ**

Spring Security æ˜¯ Spring æ¡†æ¶çš„å®‰å…¨æ¨¡çµ„ï¼Œæä¾›ï¼š
- **èªè­‰ (Authentication)**: ç¢ºèªä½¿ç”¨è€…èº«ä»½
- **æˆæ¬Š (Authorization)**: æ§åˆ¶ä½¿ç”¨è€…å¯ä»¥å­˜å–å“ªäº›è³‡æº
- **æœƒè©±ç®¡ç†**: ç®¡ç†ä½¿ç”¨è€…ç™»å…¥ç‹€æ…‹
- **å¯†ç¢¼åŠ å¯†**: å®‰å…¨åœ°å„²å­˜å¯†ç¢¼

### **Spring Security æ¶æ§‹ï¼š**

```
HTTP Request â†’ Security Filter Chain â†’ Authentication â†’ Authorization â†’ Response
```

1. **Filter Chain**: éæ¿¾å™¨éˆï¼Œè™•ç†æ‰€æœ‰è«‹æ±‚
2. **Authentication**: é©—è­‰ä½¿ç”¨è€…èº«ä»½
3. **Authorization**: æª¢æŸ¥ä½¿ç”¨è€…æ¬Šé™
4. **UserDetailsService**: è¼‰å…¥ä½¿ç”¨è€…è³‡è¨Š

---

## ğŸ” **JWT (JSON Web Token) èªè­‰**

### **ä»€éº¼æ˜¯ JWTï¼Ÿ**

JWT æ˜¯ä¸€ç¨®é–‹æ”¾æ¨™æº–ï¼Œç”¨æ–¼åœ¨å„æ–¹ä¹‹é–“å®‰å…¨åœ°å‚³è¼¸è³‡è¨Šã€‚å®ƒç”±ä¸‰éƒ¨åˆ†çµ„æˆï¼š
- **Header**: æ¼”ç®—æ³•å’Œ token é¡å‹
- **Payload**: åŒ…å«è²æ˜ (claims)
- **Signature**: ç”¨æ–¼é©—è­‰ token çš„ç°½å

### **JWT çš„å„ªé»ï¼š**
- âœ… **ç„¡ç‹€æ…‹**: ä¼ºæœå™¨ä¸éœ€è¦å„²å­˜æœƒè©±è³‡è¨Š
- âœ… **å¯æ“´å±•**: é©åˆåˆ†æ•£å¼ç³»çµ±
- âœ… **è‡ªåŒ…å«**: Token åŒ…å«æ‰€æœ‰å¿…è¦è³‡è¨Š
- âœ… **è·¨åŸŸæ”¯æ´**: å¯ä»¥åœ¨ä¸åŒåŸŸåé–“ä½¿ç”¨

### **JWT å·¥ä½œæµç¨‹ï¼š**

```
1. ä½¿ç”¨è€…ç™»å…¥ â†’ 2. é©—è­‰æˆåŠŸ â†’ 3. ç”Ÿæˆ JWT â†’ 4. è¿”å› Token
5. å¾ŒçºŒè«‹æ±‚å¸¶ Token â†’ 6. é©—è­‰ Token â†’ 7. æˆæ¬Šå­˜å–
```

---

## ğŸ—ï¸ **å¯¦ä½œæ­¥é©Ÿ**

### **æ­¥é©Ÿ1: JWT Token Provider**

å»ºç«‹ `JwtTokenProvider` é¡åˆ¥ï¼Œè² è²¬ç”Ÿæˆå’Œé©—è­‰ JWT Tokenï¼š

```java
@Component
public class JwtTokenProvider {
    
    @Value("${app.jwt.secret:defaultSecretKeyForDevelopmentOnly}")
    private String jwtSecret;
    
    @Value("${app.jwt.expiration:86400000}") // 24 hours
    private long jwtExpirationMs;
    
    // Generate JWT token from authentication
    public String generateToken(Authentication authentication) {
        UserDetails userPrincipal = (UserDetails) authentication.getPrincipal();
        return generateTokenFromUsername(userPrincipal.getUsername());
    }
    
    // Validate JWT token
    public boolean validateToken(String token) {
        try {
            SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes());
            Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}
```

### **æ­¥é©Ÿ2: JWT èªè­‰éæ¿¾å™¨**

å»ºç«‹ `JwtAuthenticationFilter`ï¼Œå¾ HTTP è«‹æ±‚ä¸­æå– JWT Tokenï¼š

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);
            
            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromToken(jwt);
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("Could not set user authentication in security context", ex);
        }
        
        filterChain.doFilter(request, response);
    }
}
```

### **æ­¥é©Ÿ3: è‡ªå®šç¾© UserDetailsService**

å»ºç«‹ `CustomUserDetailsService`ï¼Œå¾è³‡æ–™åº«è¼‰å…¥ä½¿ç”¨è€…è³‡è¨Šï¼š

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
        
        return createUserDetails(user);
    }
    
    private UserDetails createUserDetails(User user) {
        String role = user.getRole() != null ? user.getRole().getName() : "USER";
        
        return org.springframework.security.core.userdetails.User.builder()
            .username(user.getUsername())
            .password(user.getPassword())
            .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + role)))
            .disabled(!user.getIsVerified())
            .build();
    }
}
```

### **æ­¥é©Ÿ4: Spring Security é…ç½®**

å»ºç«‹ `SecurityConfig`ï¼Œé…ç½®èªè­‰å’Œæˆæ¬Šè¦å‰‡ï¼š

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                // Public endpoints - no authentication required
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/books/**").permitAll()
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                
                // Endpoints requiring authentication
                .requestMatchers("/api/borrows/**").authenticated()
                .requestMatchers("/api/users/**").authenticated()
                
                // Endpoints requiring specific roles
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/librarian/**").hasRole("LIBRARIAN")
                
                // All other requests require authentication
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
```

### **æ­¥é©Ÿ5: æ›´æ–° AuthController**

åœ¨ `AuthController` ä¸­æ·»åŠ ç™»å…¥åŠŸèƒ½ï¼š

```java
@PostMapping("/login")
public ResponseEntity<ApiResponse<LoginResponse>> login(@RequestBody @Valid LoginRequest request) {
    Authentication authentication = authenticationManager.authenticate(
        new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
    );
    
    SecurityContextHolder.getContext().setAuthentication(authentication);
    String jwt = tokenProvider.generateToken(authentication);
    
    User user = userService.findByUsername(request.getUsername());
    LoginResponse loginResponse = new LoginResponse(jwt, user);
    
    return ResponseEntity.ok(ApiResponse.success(loginResponse, "Login successful"));
}
```

### **æ­¥é©Ÿ6: å¯†ç¢¼åŠ å¯†**

æ›´æ–° `UserService` ä»¥ä½¿ç”¨ BCrypt å¯†ç¢¼åŠ å¯†ï¼š

```java
@Service
public class UserService {
    
    private final PasswordEncoder passwordEncoder;
    
    public User registerUser(String username, String email, String password, String fullName) {
        // Encrypt password
        String encodedPassword = passwordEncoder.encode(password);
        
        // Create user with encrypted password
        User user = new User(username, encodedPassword, email, fullName, userRole);
        return userRepository.save(user);
    }
}
```

---

## ğŸ”‘ **æ¬Šé™æ§åˆ¶æ©Ÿåˆ¶**

### **è§’è‰²åŸºç¤æ¬Šé™æ§åˆ¶ (RBAC)**

æˆ‘å€‘å¯¦ä½œäº†ä¸‰ç¨®è§’è‰²ï¼š

1. **USER**: ä¸€èˆ¬ä½¿ç”¨è€…
   - å¯ä»¥å€Ÿé‚„æ›¸
   - å¯ä»¥æŸ¥çœ‹è‡ªå·±çš„å€Ÿé–±è¨˜éŒ„
   - å¯ä»¥æœå°‹æ›¸ç±

2. **LIBRARIAN**: åœ–æ›¸é¤¨å“¡
   - æ“æœ‰ USER çš„æ‰€æœ‰æ¬Šé™
   - å¯ä»¥ç®¡ç†æ›¸ç±
   - å¯ä»¥è™•ç†å€Ÿé‚„æ›¸æ¥­å‹™

3. **ADMIN**: ç³»çµ±ç®¡ç†å“¡
   - æ“æœ‰æ‰€æœ‰æ¬Šé™
   - å¯ä»¥ç®¡ç†ä½¿ç”¨è€…
   - å¯ä»¥æŸ¥çœ‹ç³»çµ±çµ±è¨ˆ

### **API ç«¯é»æ¬Šé™é…ç½®**

```java
// Public endpoints - no authentication required
.requestMatchers("/api/auth/**").permitAll()        // è¨»å†Šã€ç™»å…¥
.requestMatchers("/api/books/**").permitAll()       // æ›¸ç±æŸ¥è©¢
.requestMatchers("/swagger-ui/**").permitAll()      // API æ–‡ä»¶

// Endpoints requiring authentication
.requestMatchers("/api/borrows/**").authenticated() // å€Ÿé‚„æ›¸
.requestMatchers("/api/users/**").authenticated()   // ä½¿ç”¨è€…ç®¡ç†

// Endpoints requiring specific roles
.requestMatchers("/api/admin/**").hasRole("ADMIN")           // ç®¡ç†å“¡åŠŸèƒ½
.requestMatchers("/api/librarian/**").hasRole("LIBRARIAN")   // é¤¨å“¡åŠŸèƒ½
```

---

## ğŸ§ª **æ¸¬è©¦æ¬Šé™æ§åˆ¶**

### **æ¸¬è©¦æ­¥é©Ÿï¼š**

1. **è¨»å†Šä½¿ç”¨è€…**
   ```bash
   POST /api/auth/register
   {
     "username": "testuser",
     "email": "test@example.com",
     "password": "password123",
     "fullName": "Test User"
   }
   ```

2. **ç™»å…¥å–å¾— Token**
   ```bash
   POST /api/auth/login
   {
     "username": "testuser",
     "password": "password123"
   }
   ```

3. **ä½¿ç”¨ Token å­˜å–å—ä¿è­·çš„ API**
   ```bash
   GET /api/borrows/user/1
   Authorization: Bearer <your-jwt-token>
   ```

### **é æœŸçµæœï¼š**
- âœ… æ²’æœ‰ Token çš„è«‹æ±‚æœƒè¢«æ‹’çµ• (401 Unauthorized)
- âœ… ç„¡æ•ˆ Token çš„è«‹æ±‚æœƒè¢«æ‹’çµ• (401 Unauthorized)
- âœ… æœ‰æ•ˆ Token çš„è«‹æ±‚æœƒè¢«å…è¨±
- âœ… è§’è‰²æ¬Šé™æœƒæ­£ç¢ºé™åˆ¶å­˜å–

---

## âš™ï¸ **é…ç½®æª”æ¡ˆ**

### **application.yml é…ç½®**

```yaml
app:
  jwt:
    secret: your-secret-key-here-make-it-long-and-secure
    expiration: 86400000  # 24 hours in milliseconds
```

### **é‡è¦å®‰å…¨æ³¨æ„äº‹é …ï¼š**

1. **JWT Secret**: åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­å¿…é ˆä½¿ç”¨å¼·å¯†é‘°
2. **Token éæœŸæ™‚é–“**: è¨­å®šåˆç†çš„éæœŸæ™‚é–“
3. **HTTPS**: åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­å¿…é ˆä½¿ç”¨ HTTPS
4. **å¯†ç¢¼ç­–ç•¥**: å¯¦ä½œå¼·å¯†ç¢¼è¦æ±‚

---

## ğŸ“š **ç›¸é—œæ¦‚å¿µè§£é‡‹**

### **@EnableWebSecurity**
å•Ÿç”¨ Spring Security çš„ Web å®‰å…¨åŠŸèƒ½ã€‚

### **@EnableMethodSecurity**
å•Ÿç”¨æ–¹æ³•ç´šåˆ¥çš„å®‰å…¨è¨»è§£ï¼Œå¦‚ `@PreAuthorize`ã€‚

### **SessionCreationPolicy.STATELESS**
è¨­å®šç‚ºç„¡ç‹€æ…‹æ¨¡å¼ï¼Œä¸å»ºç«‹ HTTP æœƒè©±ã€‚

### **BCryptPasswordEncoder**
ä½¿ç”¨ BCrypt æ¼”ç®—æ³•åŠ å¯†å¯†ç¢¼ï¼Œæä¾›é¹½å€¼å’Œå¤šæ¬¡é›œæ¹Šã€‚

### **SimpleGrantedAuthority**
Spring Security çš„æ¬Šé™è¡¨ç¤ºé¡åˆ¥ï¼Œæ ¼å¼ç‚º "ROLE_è§’è‰²åç¨±"ã€‚

---

## ğŸ¯ **éšæ®µå®Œæˆæª¢æŸ¥æ¸…å–®**

- [x] JWT Token Provider å¯¦ä½œ
- [x] JWT èªè­‰éæ¿¾å™¨å¯¦ä½œ
- [x] è‡ªå®šç¾© UserDetailsService å¯¦ä½œ
- [x] Spring Security é…ç½®
- [x] ç™»å…¥ API å¯¦ä½œ
- [x] å¯†ç¢¼åŠ å¯†æ•´åˆ
- [x] è§’è‰²æ¬Šé™é…ç½®
- [x] API ç«¯é»æ¬Šé™è¨­å®š

---

## ğŸš€ **ä¸‹ä¸€æ­¥**

ç¾åœ¨æˆ‘å€‘å·²ç¶“å®Œæˆäº†æ¬Šé™æ§åˆ¶ç³»çµ±çš„å¯¦ä½œï¼æ¥ä¸‹ä¾†å¯ä»¥ï¼š

1. **éšæ®µ8: API æ–‡ä»¶ (Springdoc OpenAPI)**
   - é…ç½® Swagger UI
   - ç‚º API æ·»åŠ æ–‡ä»¶è¨»è§£
   - æ¸¬è©¦ API æ–‡ä»¶é é¢

2. **éšæ®µ9: å–®å…ƒæ¸¬è©¦**
   - ç‚º Service å±¤ç·¨å¯«æ¸¬è©¦
   - ç‚º Controller å±¤ç·¨å¯«æ¸¬è©¦
   - æ¸¬è©¦æ¬Šé™æ§åˆ¶åŠŸèƒ½

---

**æ­å–œï¼æ‚¨å·²ç¶“æˆåŠŸå¯¦ä½œäº†å®Œæ•´çš„æ¬Šé™æ§åˆ¶ç³»çµ±ï¼** ğŸ‰
